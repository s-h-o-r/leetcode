# [3356. Zero Array Transformation II](https://leetcode.com/problems/zero-array-transformation-ii/description/)

You are given an integer array `nums` of length `n` and a 2D array `queries` where `queries[i] = [li, ri, vali]`.

Each `queries[i]` represents the following action on nums:

Decrement the value at each index in the range `[li, ri]` in `nums` by at most `vali`.
The amount by which each value is decremented can be chosen independently for each index.
A Zero Array is an array with all its elements equal to 0.

Return the minimum possible non-negative value of `k`, such that after processing the first `k` queries in sequence, `nums` becomes a Zero Array. If no such `k` exists, return -1.

### Constraints:
- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 5 * 10^5`
- `1 <= queries.length <= 10^5`
- `queries[i].length == 3`
- `0 <= li <= ri < nums.length`
- `1 <= vali <= 5`
---

## Алгоритм решения:
### [Решение 1:](https://github.com/s-h-o-r/leetcode/tree/main/solutions/3356.%20Zero%20Array%20Transformation%20II/solution.cpp#L5)
Самым простым, но не самым эффективным способом решить задачу является полный перебор queries и вычитание по нужным индексам в queries значений в массиве nums. При такой логике нам понадобиться завести переменную 0, чтобы подсчитывать нули в nums. Также можно воспользоваться переменной, которая хранит сумму всех элементов nums. Нужно учитывать ограничения, данные нам задачей, поэтому в таком случае придется использовать переменную типа long long, так как в простой int `10^5` * `5 * 10^5` не влезете и произойдет переполнение при попытке суммировать большие числа. В своем решении я использовал подсчет нулей, которые посчитал в цикле. Эта переменная теперь хранит актуально значение нулей в массиве nums и мы сможем использовать ее для проверки.
Теперь перейдем к вычитанию. Мы будем проходиться по всем запросам, а в каждом запросе будем проходиться по указанному в запросе диапазону и пытаться отнять значение, указанное в `queries[i][2]`. Если результатом вычитания является <= 0, то мы увеличиваем на один счетчик наших нулей. Еще одним важным условием цикла запросов является проверка на количество нулей в нашем nums. Это нужно для того, чтобы вовремя выйти из цикла и не делать лишние итерации, если мы уже уменьшили все значения nums до нуля.
Может так получится, что только на последней итерации мы получим нужное количество нулей. Поэтому при возврате значения проверяем равно ли количество итераций размеру nums и возвращаем либо количество обработанных запросов, либо -1.

Сложность: О(m * n), где n - nums.length, а m - количество запросов в queries.
Память: О(1)

### [Решение 2:](https://github.com/s-h-o-r/leetcode/tree/main/solutions/3356.%20Zero%20Array%20Transformation%20II/solution.cpp#L30)
Для решения нам помогут две техники:
1. Массив разности ([difference array](https://teckbakers.hashnode.dev/difference-array-technique))
2. Префиксная сумма ([Prefix sum](https://en.wikipedia.org/wiki/Prefix_sum))

Если коротко, то массив разности - массив значений, который строиться на основе наших запросов. В таком массиве мы по left и right + 1 индексам отмечаем, с какого индекса мы прибавляем определенное числа, а когда убираем. Все станет намного проще, если посмотреть популярные объяснения ([тык](https://teckbakers.hashnode.dev/difference-array-technique)). Этот вспомогательный массив поможет нам определить, какое максимальное значение мы сможем отнять по определенному индексу. Но не сам по себе, а с использованием префиксной суммы.
Префиксная сумма - массив, в котором последовательно хранятся суммы элементов, которые идут до индекса n включительно. Применив префиксную сумму к нашему массиву разности мы получим максимальное значение, которое мы сможем отнять по индексу.
Эти техники позволят нам легко за O(n) определить, является ли nums Zero Array.

Но этого не достаточно, чтобы оптимизировать алгоритм. Нужно также воспользоваться бинарным поиском по queries, чтобы более эффективно найти искомое значение. Для этого проходимся бинарным поиском по запросам и пытаемся выяснить, является ли nums Zero Array после очередного запроса. Проверяем бинарным поиском запросы до конца и в конце получаем нужное количество запросов для получения Zero Array. Но нужно также быть осторожным и не забыть сравнить индекс с queries.size(), потому что если мы ушли за пределы queries, то это означает, что ответа у нас нет.


Сложность: О((n + m) * log(m)), где n - nums.length, а m - количестко запросов в queries.
Память: О(n)
