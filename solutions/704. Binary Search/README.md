# [704. Binary Search](https://leetcode.com/problems/binary-search/description/)

Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

### Constraints:
- `1 <= nums.length <= 104`
- `10^4 < nums[i], target < 10^4`
- All the integers in `nums` are unique.
- `nums` is sorted in ascending order.
---

## Алгоритм решения:
Реализация простого бинарного поиска (по сути мы здесь ищем элемент не меньший, чем target, если такой существует).
1. Создаем переменные `size` (для хранения текущего размера подмассива) и `begin` (для хранения начала подмассива).
2. Пока размер нашего подмассива имеет элементы, то есть больше 0, мы ищем центр этого подмассива и проверяем элемент по центру.
3. Если элемент меньше `target`, то мы двигаем начало подмассива на следующий после центра элемент (центр мы уже проверили и его знаем). Из размеров нам надо вычесть `step + 1`, чтобы получить размер нового подмассива. Таким образом мы отсечем всю левую часть подмассива. В ином случае нам надо отсечь правую часть подмассива. Для этого просто устанавливаем размер массива в `step`.
4. В конце концов после выхода из цикла индекс `begin` окажется либо `size()`, если элементов больше или равно `target` не существует, либо покажет на элемент не меньший `target`. Чтобы вернуть ответ, обязательно проверяем `begin` на размерность (чтобы исключить обращение за пределы массива, если begin указывает на элемент после последнего). И проверяем элемент на равенство `target`.

Сложность: О(log(n))
Память: О(1)